
/* This file is generated by glib-mkenums, do not modify it. This code is licensed under the same license as the containing project. Note that it links to GLib, so must comply with the LGPL linking clauses. */

#include "fpi-enums.h"
#include "fpi-assembling.h"
#include "fpi-byte-reader.h"
#include "fpi-byte-utils.h"
#include "fpi-byte-writer.h"
#include "fpi-compat.h"
#include "fpi-context.h"
#include "fpi-device.h"
#include "fpi-image-device.h"
#include "fpi-image.h"
#include "fpi-log.h"
#include "fpi-minutiae.h"
#include "fpi-print.h"
#include "fpi-usb-transfer.h"
#include "fpi-ssm.h"

#define C_ENUM(v) ((gint) v)
#define C_FLAGS(v) ((guint) v)

/* enumerations from "fpi-device.h" */

GType
fpi_device_action_get_type (void)
{
  static volatile gsize gtype_id = 0;
  static const GEnumValue values[] = {
    { C_ENUM(FPI_DEVICE_ACTION_NONE), "FPI_DEVICE_ACTION_NONE", "none" },
    { C_ENUM(FPI_DEVICE_ACTION_PROBE), "FPI_DEVICE_ACTION_PROBE", "probe" },
    { C_ENUM(FPI_DEVICE_ACTION_OPEN), "FPI_DEVICE_ACTION_OPEN", "open" },
    { C_ENUM(FPI_DEVICE_ACTION_CLOSE), "FPI_DEVICE_ACTION_CLOSE", "close" },
    { C_ENUM(FPI_DEVICE_ACTION_ENROLL), "FPI_DEVICE_ACTION_ENROLL", "enroll" },
    { C_ENUM(FPI_DEVICE_ACTION_VERIFY), "FPI_DEVICE_ACTION_VERIFY", "verify" },
    { C_ENUM(FPI_DEVICE_ACTION_IDENTIFY), "FPI_DEVICE_ACTION_IDENTIFY", "identify" },
    { C_ENUM(FPI_DEVICE_ACTION_CAPTURE), "FPI_DEVICE_ACTION_CAPTURE", "capture" },
    { C_ENUM(FPI_DEVICE_ACTION_LIST), "FPI_DEVICE_ACTION_LIST", "list" },
    { C_ENUM(FPI_DEVICE_ACTION_DELETE), "FPI_DEVICE_ACTION_DELETE", "delete" },
    { 0, NULL, NULL }
  };
  if (g_once_init_enter (&gtype_id)) {
    GType new_type = g_enum_register_static (g_intern_static_string ("FpiDeviceAction"), values);
    g_once_init_leave (&gtype_id, new_type);
  }
  return (GType) gtype_id;
}

/* enumerations from "fpi-image-device.h" */

GType
fpi_image_device_state_get_type (void)
{
  static volatile gsize gtype_id = 0;
  static const GEnumValue values[] = {
    { C_ENUM(FPI_IMAGE_DEVICE_STATE_INACTIVE), "FPI_IMAGE_DEVICE_STATE_INACTIVE", "inactive" },
    { C_ENUM(FPI_IMAGE_DEVICE_STATE_AWAIT_FINGER_ON), "FPI_IMAGE_DEVICE_STATE_AWAIT_FINGER_ON", "await-finger-on" },
    { C_ENUM(FPI_IMAGE_DEVICE_STATE_CAPTURE), "FPI_IMAGE_DEVICE_STATE_CAPTURE", "capture" },
    { C_ENUM(FPI_IMAGE_DEVICE_STATE_AWAIT_FINGER_OFF), "FPI_IMAGE_DEVICE_STATE_AWAIT_FINGER_OFF", "await-finger-off" },
    { 0, NULL, NULL }
  };
  if (g_once_init_enter (&gtype_id)) {
    GType new_type = g_enum_register_static (g_intern_static_string ("FpiImageDeviceState"), values);
    g_once_init_leave (&gtype_id, new_type);
  }
  return (GType) gtype_id;
}

/* enumerations from "fpi-image.h" */

GType
fpi_image_flags_get_type (void)
{
  static volatile gsize gtype_id = 0;
  static const GFlagsValue values[] = {
    { C_FLAGS(FPI_IMAGE_V_FLIPPED), "FPI_IMAGE_V_FLIPPED", "v-flipped" },
    { C_FLAGS(FPI_IMAGE_H_FLIPPED), "FPI_IMAGE_H_FLIPPED", "h-flipped" },
    { C_FLAGS(FPI_IMAGE_COLORS_INVERTED), "FPI_IMAGE_COLORS_INVERTED", "colors-inverted" },
    { C_FLAGS(FPI_IMAGE_PARTIAL), "FPI_IMAGE_PARTIAL", "partial" },
    { 0, NULL, NULL }
  };
  if (g_once_init_enter (&gtype_id)) {
    GType new_type = g_flags_register_static (g_intern_static_string ("FpiImageFlags"), values);
    g_once_init_leave (&gtype_id, new_type);
  }
  return (GType) gtype_id;
}

/* enumerations from "fpi-print.h" */

GType
fpi_print_type_get_type (void)
{
  static volatile gsize gtype_id = 0;
  static const GEnumValue values[] = {
    { C_ENUM(FPI_PRINT_UNDEFINED), "FPI_PRINT_UNDEFINED", "undefined" },
    { C_ENUM(FPI_PRINT_RAW), "FPI_PRINT_RAW", "raw" },
    { C_ENUM(FPI_PRINT_NBIS), "FPI_PRINT_NBIS", "nbis" },
    { 0, NULL, NULL }
  };
  if (g_once_init_enter (&gtype_id)) {
    GType new_type = g_enum_register_static (g_intern_static_string ("FpiPrintType"), values);
    g_once_init_leave (&gtype_id, new_type);
  }
  return (GType) gtype_id;
}

GType
fpi_match_result_get_type (void)
{
  static volatile gsize gtype_id = 0;
  static const GEnumValue values[] = {
    { C_ENUM(FPI_MATCH_ERROR), "FPI_MATCH_ERROR", "error" },
    { C_ENUM(FPI_MATCH_FAIL), "FPI_MATCH_FAIL", "fail" },
    { C_ENUM(FPI_MATCH_SUCCESS), "FPI_MATCH_SUCCESS", "success" },
    { 0, NULL, NULL }
  };
  if (g_once_init_enter (&gtype_id)) {
    GType new_type = g_enum_register_static (g_intern_static_string ("FpiMatchResult"), values);
    g_once_init_leave (&gtype_id, new_type);
  }
  return (GType) gtype_id;
}

/* enumerations from "fpi-usb-transfer.h" */

GType
fpi_transfer_type_get_type (void)
{
  static volatile gsize gtype_id = 0;
  static const GEnumValue values[] = {
    { C_ENUM(FP_TRANSFER_NONE), "FP_TRANSFER_NONE", "none" },
    { C_ENUM(FP_TRANSFER_BULK), "FP_TRANSFER_BULK", "bulk" },
    { C_ENUM(FP_TRANSFER_CONTROL), "FP_TRANSFER_CONTROL", "control" },
    { C_ENUM(FP_TRANSFER_INTERRUPT), "FP_TRANSFER_INTERRUPT", "interrupt" },
    { 0, NULL, NULL }
  };
  if (g_once_init_enter (&gtype_id)) {
    GType new_type = g_enum_register_static (g_intern_static_string ("FpiTransferType"), values);
    g_once_init_leave (&gtype_id, new_type);
  }
  return (GType) gtype_id;
}

/* Generated data ends here */

